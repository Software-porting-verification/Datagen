#! /usr/bin/env python3

####################################################
#
#
# dataset generator
#
# Author: Mao Yifu, maoif@ios.ac.cn
#
#
####################################################

import os
import sys
import argparse
import yaml
import trace_datum
import socket
from trace_datum import *


g_package: str = ''
g_version: str = ''
g_true_exes = []

ARG_FLAG    = 'op_flag'   # -v, --help
# TODO -I../lib
# ARG_OP     = 'op'     # --input bla, --files f1 f2
ARG_OP_ARG  = 'op_arg' # --quality=9, if=/dev/null
ARG_NUMBER  = 'op_num'
ARG_STRING  = 'op_str'
ARG_PATH    = 'op_path'
ARG_URL     = 'op_url'
ARG_IP      = 'op_ip'
ARG_UNKNOWN = 'op_unknown'


def is_number(n):
    is_number = True
    try:
        num = float(n)
    except ValueError:
        is_number = False
    return is_number


def is_url(s):
    for prefix in ['http://', 'https://', 'ftp://', 'file://', 'data://']:
        if s.startswith(prefix):
            return True
    return False


def is_ip(s):
    parts = s.split(':')
    if len(parts) <= 2:
        try:
            ignore = socket.inet_aton(parts[0])
            return True
        except OSError:
            return False

    return False


def is_path(s):
    return False


def classify_args(args: list[str]):
    results = []
    length = len(args)

    for i in range(length):
        arg = args[i]
        
        try:
            if arg.startswith('--') or arg.startswith('-'):
                if '=' in arg:
                    results.append({ ARG_OP_ARG : arg })
                else:
                    results.append({ ARG_FLAG : arg })
            elif is_url(arg):
                results.append({ ARG_URL : arg })
            elif is_number(arg):
                results.append({ ARG_NUMBER : arg })
            elif '=' in arg:
                # dd if=/dev/zero
                results.append({ ARG_OP_ARG : arg })
            elif is_ip(arg):
                results.append({ ARG_IP : arg })
            elif is_path(arg):
                results.append({ ARG_PATH : arg })
            else:
                # TODO subcommands like `perf report`
                results.append({ ARG_UNKNOWN : arg })
        except TypeError:
            print(f'classify_args error: {arg}')
            print(f'in \n {args}')
            
    return results
            

def analyze_envs():
    pass


def filter_result(datum: TraceDatum):
    callee = datum.file_path

    if not g_true_exes == []:
        if callee not in g_true_exes:
            return False

    filter_prefixes = ['/bin/', '/usr/', '/sbin/', '/snap/', '/opt/', '/tmp/', '/etc/']
    for p in filter_prefixes:
       if callee.startswith(p):
            return False

    filter_suffixes = ['./conftest', './configure', '.build.command', '/bin/sh', '/.', '.sh'
                       'config.guess']
    for p in filter_suffixes:
       if callee.endswith(p):
            return False

    filter_infixes = ['./exec.cmd']
    for p in filter_infixes:
       if p in callee:
            return False

    return datum.check_fields()


def to_absolute_path(data: list[TraceDatum]):
    for d in data:
        exe = d.file_path
        # caller's working dir
        pwd = d.working_dir

        # convert to absolute path
        if not exe.startswith('/'):
            exe = pwd + '/' + exe

        d.file_path = exe


def analyzer_for_fuzz(data: list[TraceDatum]):
    results = []

    for d in data:
        # fuzz data should not be deduplicated
        args_classified = classify_args(d.args[1:])
        results.append({ d.file_path : [d.incomplete_args, 
                                        d.incomplete_envs, 
                                        { 'raw_args' : d.args,
                                          'classified_args' : args_classified }]})

    return results


def analyze(data: list[TraceDatum]):
    to_absolute_path(data)
    filtered = list(filter(lambda d: filter_result(d), data))
    fuzz = analyzer_for_fuzz(filtered)
    perf = list(set([d.file_path for d in filtered]))

    return fuzz, perf


def check_file(f):
    if not os.path.exists(f):
        print(f'{f} not found')
        exit(-1)
    elif not os.path.isfile(f):
        print(f'{f} is not a file')

###
### start of program
###

parser = argparse.ArgumentParser(
    prog='datagen',
    description='Analyze bpftrace data and generate dataset.')
parser.add_argument('rawfile', help='raw trace files in yaml format')
parser.add_argument('--refinement', help='refinement data generated by perf-wrapper')

args = parser.parse_args()

rawfile = args.rawfile
refinement = args.refinement

check_file(rawfile)
if refinement is not None:
    check_file(refinement)
    with open(refinement, 'r') as f:
        print(f'loading refinement: {refinement}')
        g_true_exes = yaml.load(f, Loader=yaml.Loader)
        print(f'loading refinement: {refinement} done')

with open(rawfile, 'r') as f:
    print(f'loading {rawfile}')
    data = yaml.load(f, Loader=yaml.Loader)
    print(f'loading {rawfile} done')
    g_package = data['package']
    g_version = data['version']
    fuzz, perf = analyze(data['data'])
    
    fuzz_path = f'{g_package}-{g_version}-fuzz'
    perf_path = f'{g_package}-{g_version}-perf'
    with open(fuzz_path, 'w') as f_fuzz:
        yaml.dump(fuzz, f_fuzz)
        print(f'{rawfile} fuzz dataset at {fuzz_path}')
    with open(perf_path, 'w') as f_perf:
        yaml.dump(perf, f_perf)
        print(f'{rawfile} perf dataset at {perf_path}')
